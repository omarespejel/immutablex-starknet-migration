# IMMUTABLEX-STARKNET-MIGRATION Project Context & Goal

## Goal for the LLM
You are an expert full-stack blockchain developer with deep expertise in:
- NestJS backend architecture and dependency injection
- Starknet smart contracts (Cairo language)
- Account abstraction and session keys
- WebSocket real-time communication
- Transaction batching and gas optimization
- Paymaster integration (AVNU)
- Redis/Bull queue processing
- Unity C# client integration
- Docker containerization
- Bun runtime and package management
- JWT authentication and session management
- Cryptographic key encryption/decryption

Your task is to analyze the complete context of this ImmutableX to Starknet migration project. The system features:
- NestJS backend API server
- Self-custody wallet generation
- Session key management (24hr expiry)
- Transaction batching (100 actions per batch)
- AVNU Paymaster integration for gasless transactions
- WebSocket gateway for real-time game actions
- Redis/Bull queue for async transaction processing
- Unity client integration ready
- Docker compose setup (Redis + Postgres)

Please review the project structure, dependencies, source code, and configuration,
then provide specific, actionable advice for improvement. Focus on:
- NestJS best practices and module architecture
- Service optimization and dependency injection patterns
- Starknet integration patterns (Account abstraction, session keys)
- Transaction batching efficiency and gas optimization
- Paymaster integration and error handling
- WebSocket connection management and scalability
- Queue processing reliability and error recovery
- Security best practices (key encryption, JWT handling)
- Error handling and logging strategies
- API design and RESTful conventions
- TypeScript type safety and interfaces
- Docker compose configuration
- Unity client integration patterns
- Testing strategies (unit, integration, e2e)
- Performance monitoring and metrics
- Deployment strategies (production readiness)

---

## Directory Structure
.
â”œâ”€â”€ README.md
â”œâ”€â”€ SETUP_COMPLETE.md
â”œâ”€â”€ backend
â”‚Â Â  â”œâ”€â”€ README.md
â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ app.module.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game.gateway.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ game.module.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ transaction-batch.processor.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ transaction-receipt.guard.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ main.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ paymaster
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ paymaster.module.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ paymaster.service.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ session
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ session.controller.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ session.module.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ session.service.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ wallet
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ wallet-deployment.processor.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ wallet.controller.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ wallet.module.ts
â”‚Â Â  â”‚Â Â      â””â”€â”€ wallet.service.ts
â”‚Â Â  â”œâ”€â”€ test
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ e2e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ wallet.e2e.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ websocket.e2e.test.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ setup.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ wallet.service.test.ts
â”‚Â Â  â””â”€â”€ tsconfig.json
â”œâ”€â”€ contracts
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docs
â”œâ”€â”€ generate-context.sh
â”œâ”€â”€ immutablex-starknet-migration-context-2025-11-05_21-03-30_CST.txt
â””â”€â”€ unity-client
    â””â”€â”€ Assets
        â”œâ”€â”€ Plugins
        â”‚Â Â  â”œâ”€â”€ Android
        â”‚Â Â  â””â”€â”€ iOS
        â””â”€â”€ Scripts
            â””â”€â”€ SecureStorage.cs

18 directories, 29 files

## FILE: README.md
# ImmutableX to Starknet Migration Kit

## Architecture

Unity â†’ Backend API â†’ Starknet

## Tech Stack

- Backend: NestJS + Bun + Starknet.js
- Frontend: Unity (C#)
- Blockchain: Starknet
- Queue: Redis + Bull
- Paymaster: AVNU

## Quick Start

### Prerequisites

- Bun installed
- Docker installed
- Unity 2022.3.15f1+

### Backend Setup

```bash
cd backend
bun install
cp .env.example .env
# Edit .env with your configuration
bun run dev
```

### Unity Setup

1. Open unity-client in Unity
2. Import NativeWebSocket
3. Configure backend URL
4. Build for mobile

## Features

- âœ… Self-custody wallets
- âœ… Session keys (24hr)
- âœ… Transaction batching (100 actions)
- âœ… AVNU Paymaster
- âœ… WebSocket real-time

## Environment Variables

Copy `.env.example` to `.env` and configure:

- AVNU_API_KEY
- JWT_SECRET
- STARKNET_RPC

## Running Everything Together

### Terminal 1: Start Redis
```bash
docker-compose up redis
```

### Terminal 2: Start Backend
```bash
cd backend
bun run dev
```

## Verification Checklist

- âœ… Backend Running: http://localhost:3000
- âœ… Redis Connected: Check logs for connection
- âœ… Wallet Creation: Test endpoint works
- âœ… Session Creation: JWT token returned
- âœ… WebSocket: Can connect from client

## Project Structure

```
immutablex-starknet-migration/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ wallet/
â”‚   â”‚   â”œâ”€â”€ session/
â”‚   â”‚   â”œâ”€â”€ paymaster/
â”‚   â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â””â”€â”€ main.ts
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ bun.lockb
â”‚   â””â”€â”€ .env
â”œâ”€â”€ unity-client/
â”‚   â””â”€â”€ (Unity project files)
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ README.md
â””â”€â”€ .gitignore
```

---

## FILE: docker-compose.yml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes

  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: ggmetagame
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  redis_data:
  postgres_data:

---

## FILE: .gitignore
node_modules/
.env
*.log
dist/
build/

---

## FILE: ./generate-context.sh
#!/bin/bash

#
# Description:
# This script generates a comprehensive prompt for an LLM by concatenating key source
# files from the IMMUTABLEX-STARKNET-MIGRATION project, including NestJS backend,
# Cairo contracts, Unity client, and deployment configuration.
#
# Usage:
# ./generate-context.sh
#

# --- Configuration ---
# Get current date for the output filename (ISO 8601 format for best practices)
DATE=$(date '+%Y-%m-%d_%H-%M-%S_%Z')

# Output filename with descriptive name following best practices
OUTPUT_FILE="immutablex-starknet-migration-context-${DATE}.txt"

# --- Script Body ---
# Clean up any previous output file to start fresh
rm -f "$OUTPUT_FILE"

echo "ðŸš€ Starting LLM prompt generation for the IMMUTABLEX-STARKNET-MIGRATION project..."
echo "------------------------------------------------------------"
echo "Output will be saved to: $OUTPUT_FILE"
echo ""

# 1. Add a Preamble and Goal for the LLM
echo "Adding LLM preamble and goal..."
{
  echo "# IMMUTABLEX-STARKNET-MIGRATION Project Context & Goal"
  echo ""
  echo "## Goal for the LLM"
  echo "You are an expert full-stack blockchain developer with deep expertise in:"
  echo "- NestJS backend architecture and dependency injection"
  echo "- Starknet smart contracts (Cairo language)"
  echo "- Account abstraction and session keys"
  echo "- WebSocket real-time communication"
  echo "- Transaction batching and gas optimization"
  echo "- Paymaster integration (AVNU)"
  echo "- Redis/Bull queue processing"
  echo "- Unity C# client integration"
  echo "- Docker containerization"
  echo "- Bun runtime and package management"
  echo "- JWT authentication and session management"
  echo "- Cryptographic key encryption/decryption"
  echo ""
  echo "Your task is to analyze the complete context of this ImmutableX to Starknet migration project. The system features:"
  echo "- NestJS backend API server"
  echo "- Self-custody wallet generation"
  echo "- Session key management (24hr expiry)"
  echo "- Transaction batching (100 actions per batch)"
  echo "- AVNU Paymaster integration for gasless transactions"
  echo "- WebSocket gateway for real-time game actions"
  echo "- Redis/Bull queue for async transaction processing"
  echo "- Unity client integration ready"
  echo "- Docker compose setup (Redis + Postgres)"
  echo ""
  echo "Please review the project structure, dependencies, source code, and configuration,"
  echo "then provide specific, actionable advice for improvement. Focus on:"
  echo "- NestJS best practices and module architecture"
  echo "- Service optimization and dependency injection patterns"
  echo "- Starknet integration patterns (Account abstraction, session keys)"
  echo "- Transaction batching efficiency and gas optimization"
  echo "- Paymaster integration and error handling"
  echo "- WebSocket connection management and scalability"
  echo "- Queue processing reliability and error recovery"
  echo "- Security best practices (key encryption, JWT handling)"
  echo "- Error handling and logging strategies"
  echo "- API design and RESTful conventions"
  echo "- TypeScript type safety and interfaces"
  echo "- Docker compose configuration"
  echo "- Unity client integration patterns"
  echo "- Testing strategies (unit, integration, e2e)"
  echo "- Performance monitoring and metrics"
  echo "- Deployment strategies (production readiness)"
  echo ""
  echo "---"
  echo ""
} >> "$OUTPUT_FILE"

# 2. Add the project's directory structure (cleaned up)
echo "Adding cleaned directory structure..."
echo "## Directory Structure" >> "$OUTPUT_FILE"
if command -v tree &> /dev/null; then
    echo "  -> Adding directory structure (tree -L 4)"
    # Exclude common noise from the tree view
    tree -L 4 -I "node_modules|dist|.git|.DS_Store|bun.lock|*.log|build|Library|Temp|obj|*.csproj" >> "$OUTPUT_FILE"
else
    echo "  -> WARNING: 'tree' command not found. Using find instead."
    echo "NOTE: 'tree' command was not found. Directory listing:" >> "$OUTPUT_FILE"
    find . -maxdepth 3 -not -path '*/node_modules/*' -not -path '*/.git/*' -not -path '*/dist/*' -not -path '*/build/*' -not -path '*/Library/*' -not -path '*/Temp/*' | head -50 >> "$OUTPUT_FILE"
fi
echo "" >> "$OUTPUT_FILE"

# 3. Add Core Project and Configuration Files
echo "Adding core project and configuration files..."
# Core files that provide project context
CORE_FILES=(
  "README.md"
  "docker-compose.yml"
  ".gitignore"
  "$0" # This script itself
)

for file in "${CORE_FILES[@]}"; do
  if [ -f "$file" ]; then
    echo "  -> Adding $file"
    echo "## FILE: $file" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  else
    echo "  -> WARNING: $file not found. Skipping."
  fi
done

# 4. Add Backend Configuration Files
echo "Adding backend configuration files..."
BACKEND_CONFIG_FILES=(
  "backend/package.json"
  "backend/tsconfig.json"
  "backend/.env.example"
  "backend/README.md"
)

for file in "${BACKEND_CONFIG_FILES[@]}"; do
  if [ -f "$file" ]; then
    echo "  -> Adding $file"
    echo "## FILE: $file" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  else
    echo "  -> WARNING: $file not found. Skipping."
  fi
done

# 5. Add all backend source files from backend/src/
echo "Adding backend source files from backend/src/..."
if [ -d "backend/src" ]; then
  echo "  -> Found backend/src/ directory; adding its files"
  # Find all TypeScript files
  find "backend/src" -type f \( -name "*.ts" -o -name "*.tsx" \) \
    -not -path "*/node_modules/*" \
    -not -path "*/dist/*" \
    | sort | while read -r src_file; do
      echo "  -> Adding source file: $src_file"
      echo "## FILE: $src_file" >> "$OUTPUT_FILE"
      cat "$src_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> WARNING: backend/src/ directory not found."
fi

# 6. Add backend modules (organized by feature)
echo "Adding backend modules..."

# Wallet module
if [ -d "backend/src/wallet" ]; then
  find "backend/src/wallet" -type f \( -name "*.ts" \) \
    | sort | while read -r module_file; do
      echo "  -> Adding wallet module file: $module_file"
      echo "## FILE: $module_file" >> "$OUTPUT_FILE"
      cat "$module_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
fi

# Session module
if [ -d "backend/src/session" ]; then
  find "backend/src/session" -type f \( -name "*.ts" \) \
    | sort | while read -r module_file; do
      echo "  -> Adding session module file: $module_file"
      echo "## FILE: $module_file" >> "$OUTPUT_FILE"
      cat "$module_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
fi

# Game module
if [ -d "backend/src/game" ]; then
  find "backend/src/game" -type f \( -name "*.ts" \) \
    | sort | while read -r module_file; do
      echo "  -> Adding game module file: $module_file"
      echo "## FILE: $module_file" >> "$OUTPUT_FILE"
      cat "$module_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
fi

# Paymaster module
if [ -d "backend/src/paymaster" ]; then
  find "backend/src/paymaster" -type f \( -name "*.ts" \) \
    | sort | while read -r module_file; do
      echo "  -> Adding paymaster module file: $module_file"
      echo "## FILE: $module_file" >> "$OUTPUT_FILE"
      cat "$module_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
fi

# Config module (if exists)
if [ -d "backend/src/config" ]; then
  find "backend/src/config" -type f \( -name "*.ts" \) \
    | sort | while read -r config_file; do
      echo "  -> Adding config file: $config_file"
      echo "## FILE: $config_file" >> "$OUTPUT_FILE"
      cat "$config_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
fi

# 7. Add Cairo contracts (if any)
echo "Adding Cairo contracts..."
if [ -d "contracts" ]; then
  find "contracts" -type f \( -name "*.cairo" -o -name "Scarb.toml" -o -name "*.toml" \) \
    -not -path "*/target/*" \
    | sort | while read -r contract_file; do
      echo "  -> Adding contract file: $contract_file"
      echo "## FILE: $contract_file" >> "$OUTPUT_FILE"
      cat "$contract_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No contracts directory found. Skipping."
fi

# 8. Add Unity client files (if any relevant config)
echo "Adding Unity client configuration..."
if [ -d "unity-client" ]; then
  # Only include configuration files, not binaries
  find "unity-client" -type f \( -name "*.cs" -o -name "*.json" -o -name "*.md" -o -name "*.txt" \) \
    -not -path "*/Library/*" \
    -not -path "*/Temp/*" \
    -not -path "*/obj/*" \
    -not -path "*/build/*" \
    | head -20 | sort | while read -r unity_file; do
      echo "  -> Adding Unity file: $unity_file"
      echo "## FILE: $unity_file" >> "$OUTPUT_FILE"
      cat "$unity_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No unity-client directory found. Skipping."
fi

# 9. Add documentation files
echo "Adding documentation files..."
if [ -d "docs" ]; then
  find "docs" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.rst" \) \
    | sort | while read -r doc_file; do
      echo "  -> Adding documentation file: $doc_file"
      echo "## FILE: $doc_file" >> "$OUTPUT_FILE"
      cat "$doc_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No docs directory found. Skipping."
fi

# 10. Add configuration files (never include .env)
echo "Adding additional configuration files..."
# Never include .env to avoid secret exposure
if [ -f "backend/.env" ]; then
  echo "  -> WARNING: backend/.env detected but will NOT be included to avoid exposing secrets."
fi

CONFIG_FILES=(
  ".env.example"
  ".prettierrc"
  ".eslintrc"
  ".eslintrc.json"
  ".eslintrc.js"
  ".eslintrc.cjs"
  "tsconfig.json"
  "jsconfig.json"
)

for config_file in "${CONFIG_FILES[@]}"; do
  if [ -f "$config_file" ]; then
    echo "  -> Adding config file: $config_file"
    echo "## FILE: $config_file" >> "$OUTPUT_FILE"
    cat "$config_file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  fi
done

# Check for backend-specific config files
if [ -f "backend/.prettierrc" ] || [ -f "backend/.eslintrc*" ]; then
  find "backend" -maxdepth 1 -type f \( -name ".prettierrc*" -o -name ".eslintrc*" \) | while read -r backend_config; do
    echo "  -> Adding backend config file: $backend_config"
    echo "## FILE: $backend_config" >> "$OUTPUT_FILE"
    cat "$backend_config" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  done
fi

# --- Completion Summary ---
echo ""
echo "-------------------------------------"
echo "âœ… Prompt generation complete!"
echo "Generated on: $(date '+%A, %B %d, %Y at %I:%M:%S %p %Z')"
echo ""
echo "This context file now includes:"
echo "  âœ“ A clear goal and preamble for the LLM"
echo "  âœ“ A cleaned project directory structure"
echo "  âœ“ Core project files (README.md, docker-compose.yml)"
echo "  âœ“ Backend configuration files (package.json, tsconfig.json, .env.example)"
echo "  âœ“ All NestJS backend source code (main.ts, app.module.ts)"
echo "  âœ“ Wallet module (service, controller)"
echo "  âœ“ Session module (service, controller, JWT handling)"
echo "  âœ“ Game module (WebSocket gateway, transaction processor)"
echo "  âœ“ Paymaster module (AVNU integration)"
echo "  âœ“ Cairo smart contracts (if present)"
echo "  âœ“ Unity client source files (C# scripts, configs)"
echo "  âœ“ Documentation files"
echo "  âœ“ Additional configuration files"
echo ""
echo "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"
echo "Total lines: $(wc -l < "$OUTPUT_FILE" | xargs)"
echo ""
echo "You can now use the content of '$OUTPUT_FILE' as a context prompt for your LLM."
echo "Perfect for getting comprehensive code reviews, architecture advice, or feature suggestions!"
echo ""
echo "ðŸ’¡ Tip: This is especially useful for:"
echo "   - NestJS module architecture optimization"
echo "   - Starknet integration patterns (Account abstraction)"
echo "   - Session key management improvements"
echo "   - Transaction batching efficiency"
echo "   - Paymaster integration error handling"
echo "   - WebSocket scalability and connection management"
echo "   - Queue processing reliability"
echo "   - Security best practices (encryption, JWT)"
echo "   - TypeScript type safety improvements"
echo "   - API design and RESTful conventions"
echo "   - Docker compose optimization"
echo "   - Unity client integration patterns"
echo "   - Testing strategy recommendations"
echo "   - Production deployment readiness"
echo ""
echo "ðŸŽ¯ Key areas to focus on:"
echo "   - Wallet generation and key encryption security"
echo "   - Session key expiry and renewal logic"
echo "   - Transaction batching algorithm and gas optimization"
echo "   - Paymaster integration error handling and retry logic"
echo "   - WebSocket connection lifecycle management"
echo "   - Queue job processing and failure recovery"
echo "   - Error handling and logging strategies"
echo "   - TypeScript interface definitions and type safety"
echo "   - API endpoint design and validation"
echo "   - Docker compose service dependencies"
echo "   - Unity WebSocket client implementation"
echo "   - Production monitoring and metrics"
echo ""

---

## FILE: backend/package.json
{
  "name": "backend",
  "version": "1.0.0",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "start": "bun run dist/main.js",
    "dev": "bun run --watch src/main.ts",
    "build": "bun build src/main.ts --target=node --outdir=dist",
    "test": "bun test",
    "test:watch": "bun test --watch",
    "test:cov": "bun test --coverage",
    "format": "prettier --write \"src/**/*.ts\""
  },
  "devDependencies": {
    "@nestjs/cli": "^11.0.10",
    "@nestjs/schematics": "^11.0.9",
    "@nestjs/testing": "^11.1.8",
    "@types/bcrypt": "^6.0.0",
    "@types/bull": "^4.10.4",
    "@types/bun": "latest",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.10.0",
    "@types/supertest": "^6.0.3",
    "nock": "^14.0.10",
    "nodemon": "^3.1.10",
    "supertest": "^7.1.4",
    "ts-node": "^10.9.2"
  },
  "peerDependencies": {
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@nestjs/bull": "^11.0.4",
    "@nestjs/common": "^11.1.8",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.1.8",
    "@nestjs/jwt": "^11.0.1",
    "@nestjs/platform-express": "^11.1.8",
    "@nestjs/platform-socket.io": "^11.1.8",
    "@nestjs/throttler": "^6.4.0",
    "@nestjs/websockets": "^11.1.8",
    "bcrypt": "^6.0.0",
    "bull": "^4.16.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "exponential-backoff": "^3.1.3",
    "ioredis": "^5.8.2",
    "jsonwebtoken": "^9.0.2",
    "redis": "^5.9.0",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "starknet": "6.11.0"
  }
}

---

## FILE: backend/tsconfig.json
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}

---

## FILE: backend/.env.example
# Starknet Configuration
STARKNET_RPC=https://starknet-sepolia.public.blastapi.io
NETWORK=sepolia

# AVNU Paymaster
AVNU_PAYMASTER_URL=https://sepolia.paymaster.avnu.fi
AVNU_API_KEY=YOUR_API_KEY

# Account Configuration
ACCOUNT_CLASS_HASH=0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f

# Security
JWT_SECRET=CHANGE_THIS
ENCRYPTION_KEY=your_encryption_key_32_characters

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Server
PORT=3000

---

## FILE: backend/README.md
# backend

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.3.1. [Bun](https://bun.com) is a fast all-in-one JavaScript runtime.

---

## FILE: backend/src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { BullModule } from '@nestjs/bull';
import { ThrottlerModule } from '@nestjs/throttler';
import { WalletModule } from './wallet/wallet.module';
import { SessionModule } from './session/session.module';
import { GameModule } from './game/game.module';
import { PaymasterModule } from './paymaster/paymaster.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    ThrottlerModule.forRoot([{
      ttl: 60000, // 1 minute
      limit: 10,  // 10 requests per minute
    }]),
    BullModule.forRoot({
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT) || 6379,
      },
    }),
    WalletModule,
    SessionModule,
    GameModule,
    PaymasterModule,
  ],
})
export class AppModule {}

---

## FILE: backend/src/game/game.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { SessionService } from '../session/session.service';
import { Logger } from '@nestjs/common';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class GameGateway implements OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(GameGateway.name);
  @WebSocketServer() server: Server;

  constructor(private sessionService: SessionService) {}

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('gameAction')
  async handleGameAction(client: Socket, payload: any) {
    try {
      const result = await this.sessionService.executeAction(
        payload.sessionToken,
        payload.action
      );

      client.emit('actionConfirmed', {
        actionId: payload.action.id,
        status: 'queued',
        batchPosition: result.batchPosition,
      });
    } catch (error) {
      client.emit('actionError', {
        actionId: payload.action.id,
        error: error.message,
      });
    }
  }
}

---

## FILE: backend/src/game/game.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { GameGateway } from './game.gateway';
import { TransactionBatchProcessor } from './transaction-batch.processor';
import { TransactionReceiptGuard } from './transaction-receipt.guard';
import { SessionModule } from '../session/session.module';
import { PaymasterModule } from '../paymaster/paymaster.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'transactions',
    }),
    SessionModule,
    PaymasterModule,
  ],
  providers: [GameGateway, TransactionBatchProcessor, TransactionReceiptGuard],
  exports: [GameGateway],
})
export class GameModule {}

---

## FILE: backend/src/game/transaction-batch.processor.ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';
import { Logger } from '@nestjs/common';
import { PaymasterService } from '../paymaster/paymaster.service';
import { TransactionReceiptGuard } from './transaction-receipt.guard';

@Processor('transactions')
export class TransactionBatchProcessor {
  private readonly logger = new Logger(TransactionBatchProcessor.name);
  private actionBatch: any[] = [];
  private readonly BATCH_SIZE = 100;

  constructor(
    private paymasterService: PaymasterService,
    private receiptGuard: TransactionReceiptGuard,
  ) {}

  @Process('batch-action')
  async handleBatchAction(job: Job) {
    this.actionBatch.push(job.data);

    if (this.actionBatch.length >= this.BATCH_SIZE) {
      await this.submitBatch();
    }
  }

  private async submitBatch() {
    if (this.actionBatch.length === 0) return;

    this.logger.log(`Submitting batch of ${this.actionBatch.length} actions`);

    try {
      // Group by user and submit
      const userActions = this.groupByUser(this.actionBatch);

      for (const [userId, actions] of Object.entries(userActions)) {
        await this.submitUserBatch(userId, actions);
      }

      this.actionBatch = [];
      this.logger.log('Batch submitted successfully');
    } catch (error) {
      this.logger.error('Batch submission failed', error);
    }
  }

  private groupByUser(actions: any[]): Record<string, any[]> {
    return actions.reduce((groups, action) => {
      const userId = action.userId;
      if (!groups[userId]) groups[userId] = [];
      groups[userId].push(action);
      return groups;
    }, {});
  }

  private async submitUserBatch(userId: string, actions: any[]) {
    // Submit with paymaster
    const sponsored = await this.paymasterService.sponsorTransaction({
      userId,
      actions,
    });

    // Track transaction for receipt monitoring
    if (sponsored.transaction_hash || sponsored.transactionHash) {
      const txHash = sponsored.transaction_hash || sponsored.transactionHash;
      await this.receiptGuard.trackTransaction(txHash, {
        userId,
        actions,
      });
    }

    this.logger.log(`Batch sponsored: ${sponsored.transaction_hash || sponsored.transactionHash}`);
    return sponsored;
  }
}

---

## FILE: backend/src/game/transaction-receipt.guard.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { RpcProvider } from 'starknet';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class TransactionReceiptGuard {
  private readonly logger = new Logger(TransactionReceiptGuard.name);
  private provider: RpcProvider | null = null;
  private pendingTransactions = new Map<string, any>();

  constructor(
    private configService: ConfigService,
    @InjectQueue('transactions') private txQueue: Queue,
  ) {
    // Check pending transactions every 10 seconds
    setInterval(() => this.checkPendingTransactions(), 10000);
  }

  private getProvider(): RpcProvider {
    if (!this.provider) {
      this.provider = new RpcProvider({
        nodeUrl: this.configService.get('STARKNET_RPC') || 'https://starknet-sepolia.public.blastapi.io',
      });
    }
    return this.provider;
  }

  async trackTransaction(txHash: string, originalData: any) {
    this.pendingTransactions.set(txHash, {
      ...originalData,
      attempts: 0,
      submittedAt: Date.now(),
    });
  }

  private async checkPendingTransactions() {
    const provider = this.getProvider();
    for (const [txHash, data] of this.pendingTransactions.entries()) {
      try {
        const receipt = await provider.getTransactionReceipt(txHash);

        if (receipt.status === 'ACCEPTED_ON_L2' || receipt.status === 'ACCEPTED_ON_L1') {
          this.logger.log(`Transaction confirmed: ${txHash}`);
          this.pendingTransactions.delete(txHash);
        } else if (receipt.status === 'REJECTED') {
          this.logger.warn(`Transaction rejected, requeuing: ${txHash}`);
          await this.requeueTransaction(data);
          this.pendingTransactions.delete(txHash);
        }
      } catch (error: any) {
        // Transaction not found yet, check timeout
        if (Date.now() - data.submittedAt > 300000) { // 5 minutes timeout
          this.logger.error(`Transaction timeout, requeuing: ${txHash}`);
          await this.requeueTransaction(data);
          this.pendingTransactions.delete(txHash);
        }
      }
    }
  }

  private async requeueTransaction(data: any) {
    if (data.attempts < 3) {
      await this.txQueue.add('batch-action', {
        ...data,
        attempts: data.attempts + 1,
        requeued: true,
      }, {
        delay: 5000 * (data.attempts + 1), // Exponential delay
      });
    } else {
      this.logger.error(`Max retries exceeded for transaction`);
      // Store in dead letter queue or alert
    }
  }
}

---

## FILE: backend/src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableCors();
  app.useGlobalPipes(new ValidationPipe());

  const port = process.env.PORT || 3000;
  await app.listen(port);
  console.log(`ðŸš€ Backend running on http://localhost:${port}`);
}

bootstrap();

---

## FILE: backend/src/paymaster/paymaster.module.ts
import { Module } from '@nestjs/common';
import { PaymasterService } from './paymaster.service';

@Module({
  providers: [PaymasterService],
  exports: [PaymasterService],
})
export class PaymasterModule {}

---

## FILE: backend/src/paymaster/paymaster.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { backOff } from 'exponential-backoff';
import * as crypto from 'crypto';

interface PaymasterCache {
  headers: Record<string, string>;
  expiresAt: number;
}

@Injectable()
export class PaymasterService {
  private readonly logger = new Logger(PaymasterService.name);
  private paymasterUrl: string | null = null;
  private apiKey: string | null = null;
  private authCache: PaymasterCache | null = null;
  private requestQueue: Promise<any>[] = [];
  private readonly MAX_CONCURRENT = 10;

  constructor(private configService: ConfigService) {}

  private getPaymasterUrl(): string {
    if (!this.paymasterUrl) {
      this.paymasterUrl = this.configService.get('AVNU_PAYMASTER_URL') || 'https://sepolia.paymaster.avnu.fi';
    }
    return this.paymasterUrl;
  }

  private getApiKey(): string {
    if (!this.apiKey) {
      this.apiKey = this.configService.get('AVNU_API_KEY') || '';
    }
    return this.apiKey;
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    // Cache auth headers for 1 hour
    if (this.authCache && this.authCache.expiresAt > Date.now()) {
      return this.authCache.headers;
    }

    const headers = {
      'Content-Type': 'application/json',
      'API-Key': this.getApiKey(),
      'X-Request-ID': crypto.randomUUID(),
    };

    this.authCache = {
      headers,
      expiresAt: Date.now() + 3600000, // 1 hour
    };

    return headers;
  }

  async sponsorTransaction(transaction: any): Promise<any> {
    return await backOff(
      async () => {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.getPaymasterUrl()}/sponsor`, {
          method: 'POST',
          headers,
          body: JSON.stringify(transaction),
        });

        let responseData: any;
        try {
          responseData = await response.json();
        } catch (e) {
          // If response is not JSON, use status text
          responseData = { error: response.statusText };
        }

        // Handle specific error codes
        if (!response.ok) {
          const error = this.parsePaymasterError(response.status, responseData);

          // Determine if error is retryable
          if (error.retryable) {
            throw new Error(`Retryable error: ${error.message}`);
          } else {
            throw new Error(`Non-retryable error: ${error.message}`);
          }
        }

        return responseData;
      },
      {
        numOfAttempts: 5,
        startingDelay: 1000,
        timeMultiple: 2,
        maxDelay: 30000,
        retry: (error) => {
          return error.message.includes('Retryable');
        },
      }
    );
  }

  async sponsorAccountDeployment(deployPayload: any): Promise<any> {
    // Similar to sponsorTransaction but for account deployment
    const headers = await this.getAuthHeaders();

    return await backOff(
      async () => {
        const response = await fetch(`${this.getPaymasterUrl()}/sponsor-account-deployment`, {
          method: 'POST',
          headers,
          body: JSON.stringify(deployPayload),
        });

        if (!response.ok) {
          let errorData: any;
          try {
            errorData = await response.json();
          } catch (e) {
            errorData = { error: response.statusText };
          }
          const error = this.parsePaymasterError(response.status, errorData);

          if (error.retryable) {
            throw new Error(`Retryable: ${error.message}`);
          }
          throw new Error(`Fatal: ${error.message}`);
        }

        try {
          return await response.json();
        } catch (e) {
          return { transaction_hash: 'unknown', success: true };
        }
      },
      {
        numOfAttempts: 3,
        startingDelay: 2000,
      }
    );
  }

  private parsePaymasterError(status: number, data: any) {
    const errorMap: Record<number, { message: string; retryable: boolean }> = {
      429: { message: 'Rate limit exceeded', retryable: true },
      503: { message: 'Service temporarily unavailable', retryable: true },
      502: { message: 'Bad gateway', retryable: true },
      500: { message: 'Internal server error', retryable: true },
      401: { message: 'Invalid API key', retryable: false },
      400: { message: `Bad request: ${data.error || 'Invalid data'}`, retryable: false },
      402: { message: 'Insufficient credits', retryable: false },
    };

    return errorMap[status] || {
      message: `Unknown error: ${status}`,
      retryable: status >= 500,
    };
  }
}

---

## FILE: backend/src/session/session.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { SessionService } from './session.service';

@Controller('session')
export class SessionController {
  constructor(private sessionService: SessionService) {}

  @Post('create')
  async createSession(@Body() body: { userId: string; walletAddress: string }) {
    const token = await this.sessionService.createSession(body.userId, body.walletAddress);
    return { token };
  }
}

---

## FILE: backend/src/session/session.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { JwtModule } from '@nestjs/jwt';
import { SessionService } from './session.service';
import { SessionController } from './session.controller';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'transactions',
    }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '24h' },
    }),
  ],
  providers: [SessionService],
  controllers: [SessionController],
  exports: [SessionService],
})
export class SessionModule {}

---

## FILE: backend/src/session/session.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { JwtService } from '@nestjs/jwt';
import { ec, stark } from 'starknet';
import * as crypto from 'crypto';

interface SessionKey {
  sessionPrivateKey: string;
  sessionPublicKey: string;
  masterAddress: string;
  expiry: number;
  maxGasPerTx: string;
  allowedMethods: string[];
  userId: string;
}

@Injectable()
export class SessionService {
  private readonly logger = new Logger(SessionService.name);
  private activeSessions = new Map<string, SessionKey>();

  constructor(
    @InjectQueue('transactions') private txQueue: Queue,
    private jwtService: JwtService,
  ) {}

  async createSession(userId: string, walletAddress: string): Promise<string> {
    // Generate session keys
    const sessionPrivateKey = stark.randomAddress();
    const sessionPublicKey = ec.starkCurve.getStarkKey(sessionPrivateKey);

    const session: SessionKey = {
      sessionPrivateKey,
      sessionPublicKey,
      masterAddress: walletAddress,
      expiry: Date.now() + (24 * 60 * 60 * 1000),
      maxGasPerTx: '0.001',
      allowedMethods: ['game_action', 'claim_reward', 'update_score', 'buy_upgrade'],
      userId,
    };

    const sessionId = crypto.randomBytes(16).toString('hex');
    this.activeSessions.set(sessionId, session);

    const token = this.jwtService.sign({
      sessionId,
      sessionPublicKey,
      expiry: session.expiry,
    });

    this.logger.log(`Session created for user ${userId}`);
    return token;
  }

  async executeAction(sessionToken: string, action: any) {
    const decoded = this.jwtService.verify(sessionToken) as { sessionId: string; sessionPublicKey: string; expiry: number };
    const session = this.activeSessions.get(decoded.sessionId);

    if (!session) throw new Error('Invalid session');
    if (Date.now() > session.expiry) throw new Error('Session expired');
    if (!session.allowedMethods.includes(action.method)) throw new Error('Method not allowed');

    await this.txQueue.add('batch-action', {
      sessionId: decoded.sessionId,
      userId: session.userId,
      action,
      timestamp: Date.now(),
    });

    return {
      success: true,
      message: 'Action queued',
      batchPosition: await this.txQueue.count(),
    };
  }

  getSession(sessionId: string): SessionKey {
    return this.activeSessions.get(sessionId);
  }
}

---

## FILE: backend/src/wallet/wallet-deployment.processor.ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RpcProvider, hash } from 'starknet';
import { backOff } from 'exponential-backoff';
import { PaymasterService } from '../paymaster/paymaster.service';

@Processor('wallet-deployment')
export class WalletDeploymentProcessor {
  private readonly logger = new Logger(WalletDeploymentProcessor.name);
  private provider: RpcProvider | null = null;

  constructor(
    private configService: ConfigService,
    private paymasterService: PaymasterService,
  ) {}

  private getProvider(): RpcProvider {
    if (!this.provider) {
      this.provider = new RpcProvider({
        nodeUrl: this.configService.get('STARKNET_RPC') || 'https://starknet-sepolia.public.blastapi.io',
      });
    }
    return this.provider;
  }

  @Process({
    name: 'deploy-account',
    concurrency: 5, // Process 5 deployments in parallel
  })
  async handleDeployAccount(job: Job) {
    const { userWallet } = job.data;

    try {
      // Deploy with exponential backoff
      const result = await backOff(
        () => this.deployAccountWithPaymaster(userWallet),
        {
          numOfAttempts: 5,
          startingDelay: 1000,
          timeMultiple: 2,
          maxDelay: 30000,
          jitter: 'full',
          retry: (error, attemptNumber) => {
            this.logger.warn(`Deploy attempt ${attemptNumber} failed: ${error.message}`);
            // Retry on network errors, not on invalid data
            return !error.message.includes('invalid') && !error.message.includes('rejected');
          },
        }
      );

      // Poll for receipt confirmation
      const receipt = await this.pollTransactionReceipt(result.transaction_hash);

      this.logger.log(`Account deployed successfully: ${userWallet.address}, tx: ${receipt.transaction_hash}`);
      return receipt;
    } catch (error) {
      this.logger.error(`Failed to deploy account after all retries: ${error.message}`);
      throw error;
    }
  }

  private async deployAccountWithPaymaster(userWallet: any) {
    const accountClassHash = this.configService.get('ACCOUNT_CLASS_HASH') || '0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f';
    const deployAccountPayload = {
      classHash: accountClassHash,
      constructorCalldata: [userWallet.publicKey],
      contractAddress: userWallet.address,
      addressSalt: userWallet.publicKey,
    };

    return await this.paymasterService.sponsorAccountDeployment(deployAccountPayload);
  }

  private async pollTransactionReceipt(txHash: string, maxAttempts = 60) {
    const provider = this.getProvider();
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const receipt = await provider.getTransactionReceipt(txHash);

        if (receipt.status === 'ACCEPTED_ON_L2' || receipt.status === 'ACCEPTED_ON_L1') {
          return receipt;
        }

        if (receipt.status === 'REJECTED') {
          throw new Error(`Transaction rejected: ${txHash}`);
        }
      } catch (error: any) {
        if (!error.message?.includes('Transaction not found')) {
          throw error;
        }
      }

      // Wait 2 seconds between polls
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    throw new Error(`Transaction receipt timeout: ${txHash}`);
  }
}

---

## FILE: backend/src/wallet/wallet.controller.ts
import { Controller, Post, Body, Logger, UseGuards } from '@nestjs/common';
import { ThrottlerGuard } from '@nestjs/throttler';
import { WalletService } from './wallet.service';

@Controller('wallet')
@UseGuards(ThrottlerGuard)
export class WalletController {
  private readonly logger = new Logger(WalletController.name);

  constructor(private walletService: WalletService) {}

  @Post('create')
  async createWallet(@Body() body: { userId: string }) {
    this.logger.log(`Creating wallet for user: ${body.userId}`);
    // Rate limited to 10 calls per minute
    return await this.walletService.createUserWallet(body.userId);
  }
}

---

## FILE: backend/src/wallet/wallet.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { WalletService } from './wallet.service';
import { WalletController } from './wallet.controller';
import { WalletDeploymentProcessor } from './wallet-deployment.processor';
import { PaymasterModule } from '../paymaster/paymaster.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'wallet-deployment',
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
        removeOnComplete: true,
        removeOnFail: false,
      },
    }),
    PaymasterModule,
  ],
  providers: [WalletService, WalletDeploymentProcessor],
  controllers: [WalletController],
  exports: [WalletService],
})
export class WalletModule {}

---

## FILE: backend/src/wallet/wallet.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { ConfigService } from '@nestjs/config';
import { Account, ec, stark, RpcProvider, hash, Contract } from 'starknet';
import * as crypto from 'crypto';

@Injectable()
export class WalletService {
  private readonly logger = new Logger(WalletService.name);
  private provider: RpcProvider;

  constructor(
    private configService: ConfigService,
    @InjectQueue('wallet-deployment') private deploymentQueue: Queue,
  ) {
    this.provider = new RpcProvider({
      nodeUrl: this.configService.get('STARKNET_RPC'),
    });
  }

  async createUserWallet(userId: string) {
    this.logger.log(`Creating wallet for user: ${userId}`);

    // Generate keys
    const privateKey = stark.randomAddress();
    const publicKey = ec.starkCurve.getStarkKey(privateKey);

    // Calculate account address
    const accountClassHash = this.configService.get('ACCOUNT_CLASS_HASH');
    const accountAddress = hash.calculateContractAddressFromHash(
      publicKey,
      accountClassHash,
      [publicKey],
      0
    );

    // Encrypt private key
    const encryptedKey = this.encryptKey(privateKey, userId);

    // Queue deployment instead of doing it synchronously
    await this.deploymentQueue.add('deploy-account', {
      userWallet: {
        address: accountAddress,
        publicKey,
        userId,
      },
    }, {
      delay: 5000, // Wait 5 seconds before deployment
      priority: 1,
    });

    this.logger.log(`Wallet created: ${accountAddress}`);

    return {
      address: accountAddress,
      publicKey,
      encryptedPrivateKey: encryptedKey,
      deploymentStatus: 'queued',
    };
  }

  private encryptKey(privateKey: string, userId: string): string {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(userId, 'salt', 32);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, key, iv);

    let encrypted = cipher.update(privateKey, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return iv.toString('hex') + ':' + encrypted;
  }

  decryptKey(encryptedKey: string, userId: string): string {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(userId, 'salt', 32);
    const parts = encryptedKey.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];

    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}

---

## FILE: backend/src/wallet/wallet-deployment.processor.ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RpcProvider, hash } from 'starknet';
import { backOff } from 'exponential-backoff';
import { PaymasterService } from '../paymaster/paymaster.service';

@Processor('wallet-deployment')
export class WalletDeploymentProcessor {
  private readonly logger = new Logger(WalletDeploymentProcessor.name);
  private provider: RpcProvider | null = null;

  constructor(
    private configService: ConfigService,
    private paymasterService: PaymasterService,
  ) {}

  private getProvider(): RpcProvider {
    if (!this.provider) {
      this.provider = new RpcProvider({
        nodeUrl: this.configService.get('STARKNET_RPC') || 'https://starknet-sepolia.public.blastapi.io',
      });
    }
    return this.provider;
  }

  @Process({
    name: 'deploy-account',
    concurrency: 5, // Process 5 deployments in parallel
  })
  async handleDeployAccount(job: Job) {
    const { userWallet } = job.data;

    try {
      // Deploy with exponential backoff
      const result = await backOff(
        () => this.deployAccountWithPaymaster(userWallet),
        {
          numOfAttempts: 5,
          startingDelay: 1000,
          timeMultiple: 2,
          maxDelay: 30000,
          jitter: 'full',
          retry: (error, attemptNumber) => {
            this.logger.warn(`Deploy attempt ${attemptNumber} failed: ${error.message}`);
            // Retry on network errors, not on invalid data
            return !error.message.includes('invalid') && !error.message.includes('rejected');
          },
        }
      );

      // Poll for receipt confirmation
      const receipt = await this.pollTransactionReceipt(result.transaction_hash);

      this.logger.log(`Account deployed successfully: ${userWallet.address}, tx: ${receipt.transaction_hash}`);
      return receipt;
    } catch (error) {
      this.logger.error(`Failed to deploy account after all retries: ${error.message}`);
      throw error;
    }
  }

  private async deployAccountWithPaymaster(userWallet: any) {
    const accountClassHash = this.configService.get('ACCOUNT_CLASS_HASH') || '0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f';
    const deployAccountPayload = {
      classHash: accountClassHash,
      constructorCalldata: [userWallet.publicKey],
      contractAddress: userWallet.address,
      addressSalt: userWallet.publicKey,
    };

    return await this.paymasterService.sponsorAccountDeployment(deployAccountPayload);
  }

  private async pollTransactionReceipt(txHash: string, maxAttempts = 60) {
    const provider = this.getProvider();
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const receipt = await provider.getTransactionReceipt(txHash);

        if (receipt.status === 'ACCEPTED_ON_L2' || receipt.status === 'ACCEPTED_ON_L1') {
          return receipt;
        }

        if (receipt.status === 'REJECTED') {
          throw new Error(`Transaction rejected: ${txHash}`);
        }
      } catch (error: any) {
        if (!error.message?.includes('Transaction not found')) {
          throw error;
        }
      }

      // Wait 2 seconds between polls
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    throw new Error(`Transaction receipt timeout: ${txHash}`);
  }
}

---

## FILE: backend/src/wallet/wallet.controller.ts
import { Controller, Post, Body, Logger, UseGuards } from '@nestjs/common';
import { ThrottlerGuard } from '@nestjs/throttler';
import { WalletService } from './wallet.service';

@Controller('wallet')
@UseGuards(ThrottlerGuard)
export class WalletController {
  private readonly logger = new Logger(WalletController.name);

  constructor(private walletService: WalletService) {}

  @Post('create')
  async createWallet(@Body() body: { userId: string }) {
    this.logger.log(`Creating wallet for user: ${body.userId}`);
    // Rate limited to 10 calls per minute
    return await this.walletService.createUserWallet(body.userId);
  }
}

---

## FILE: backend/src/wallet/wallet.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { WalletService } from './wallet.service';
import { WalletController } from './wallet.controller';
import { WalletDeploymentProcessor } from './wallet-deployment.processor';
import { PaymasterModule } from '../paymaster/paymaster.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'wallet-deployment',
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
        removeOnComplete: true,
        removeOnFail: false,
      },
    }),
    PaymasterModule,
  ],
  providers: [WalletService, WalletDeploymentProcessor],
  controllers: [WalletController],
  exports: [WalletService],
})
export class WalletModule {}

---

## FILE: backend/src/wallet/wallet.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { ConfigService } from '@nestjs/config';
import { Account, ec, stark, RpcProvider, hash, Contract } from 'starknet';
import * as crypto from 'crypto';

@Injectable()
export class WalletService {
  private readonly logger = new Logger(WalletService.name);
  private provider: RpcProvider;

  constructor(
    private configService: ConfigService,
    @InjectQueue('wallet-deployment') private deploymentQueue: Queue,
  ) {
    this.provider = new RpcProvider({
      nodeUrl: this.configService.get('STARKNET_RPC'),
    });
  }

  async createUserWallet(userId: string) {
    this.logger.log(`Creating wallet for user: ${userId}`);

    // Generate keys
    const privateKey = stark.randomAddress();
    const publicKey = ec.starkCurve.getStarkKey(privateKey);

    // Calculate account address
    const accountClassHash = this.configService.get('ACCOUNT_CLASS_HASH');
    const accountAddress = hash.calculateContractAddressFromHash(
      publicKey,
      accountClassHash,
      [publicKey],
      0
    );

    // Encrypt private key
    const encryptedKey = this.encryptKey(privateKey, userId);

    // Queue deployment instead of doing it synchronously
    await this.deploymentQueue.add('deploy-account', {
      userWallet: {
        address: accountAddress,
        publicKey,
        userId,
      },
    }, {
      delay: 5000, // Wait 5 seconds before deployment
      priority: 1,
    });

    this.logger.log(`Wallet created: ${accountAddress}`);

    return {
      address: accountAddress,
      publicKey,
      encryptedPrivateKey: encryptedKey,
      deploymentStatus: 'queued',
    };
  }

  private encryptKey(privateKey: string, userId: string): string {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(userId, 'salt', 32);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(algorithm, key, iv);

    let encrypted = cipher.update(privateKey, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return iv.toString('hex') + ':' + encrypted;
  }

  decryptKey(encryptedKey: string, userId: string): string {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(userId, 'salt', 32);
    const parts = encryptedKey.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];

    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}

---

## FILE: backend/src/session/session.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { SessionService } from './session.service';

@Controller('session')
export class SessionController {
  constructor(private sessionService: SessionService) {}

  @Post('create')
  async createSession(@Body() body: { userId: string; walletAddress: string }) {
    const token = await this.sessionService.createSession(body.userId, body.walletAddress);
    return { token };
  }
}

---

## FILE: backend/src/session/session.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { JwtModule } from '@nestjs/jwt';
import { SessionService } from './session.service';
import { SessionController } from './session.controller';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'transactions',
    }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '24h' },
    }),
  ],
  providers: [SessionService],
  controllers: [SessionController],
  exports: [SessionService],
})
export class SessionModule {}

---

## FILE: backend/src/session/session.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { JwtService } from '@nestjs/jwt';
import { ec, stark } from 'starknet';
import * as crypto from 'crypto';

interface SessionKey {
  sessionPrivateKey: string;
  sessionPublicKey: string;
  masterAddress: string;
  expiry: number;
  maxGasPerTx: string;
  allowedMethods: string[];
  userId: string;
}

@Injectable()
export class SessionService {
  private readonly logger = new Logger(SessionService.name);
  private activeSessions = new Map<string, SessionKey>();

  constructor(
    @InjectQueue('transactions') private txQueue: Queue,
    private jwtService: JwtService,
  ) {}

  async createSession(userId: string, walletAddress: string): Promise<string> {
    // Generate session keys
    const sessionPrivateKey = stark.randomAddress();
    const sessionPublicKey = ec.starkCurve.getStarkKey(sessionPrivateKey);

    const session: SessionKey = {
      sessionPrivateKey,
      sessionPublicKey,
      masterAddress: walletAddress,
      expiry: Date.now() + (24 * 60 * 60 * 1000),
      maxGasPerTx: '0.001',
      allowedMethods: ['game_action', 'claim_reward', 'update_score', 'buy_upgrade'],
      userId,
    };

    const sessionId = crypto.randomBytes(16).toString('hex');
    this.activeSessions.set(sessionId, session);

    const token = this.jwtService.sign({
      sessionId,
      sessionPublicKey,
      expiry: session.expiry,
    });

    this.logger.log(`Session created for user ${userId}`);
    return token;
  }

  async executeAction(sessionToken: string, action: any) {
    const decoded = this.jwtService.verify(sessionToken) as { sessionId: string; sessionPublicKey: string; expiry: number };
    const session = this.activeSessions.get(decoded.sessionId);

    if (!session) throw new Error('Invalid session');
    if (Date.now() > session.expiry) throw new Error('Session expired');
    if (!session.allowedMethods.includes(action.method)) throw new Error('Method not allowed');

    await this.txQueue.add('batch-action', {
      sessionId: decoded.sessionId,
      userId: session.userId,
      action,
      timestamp: Date.now(),
    });

    return {
      success: true,
      message: 'Action queued',
      batchPosition: await this.txQueue.count(),
    };
  }

  getSession(sessionId: string): SessionKey {
    return this.activeSessions.get(sessionId);
  }
}

---

## FILE: backend/src/game/game.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { SessionService } from '../session/session.service';
import { Logger } from '@nestjs/common';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class GameGateway implements OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(GameGateway.name);
  @WebSocketServer() server: Server;

  constructor(private sessionService: SessionService) {}

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('gameAction')
  async handleGameAction(client: Socket, payload: any) {
    try {
      const result = await this.sessionService.executeAction(
        payload.sessionToken,
        payload.action
      );

      client.emit('actionConfirmed', {
        actionId: payload.action.id,
        status: 'queued',
        batchPosition: result.batchPosition,
      });
    } catch (error) {
      client.emit('actionError', {
        actionId: payload.action.id,
        error: error.message,
      });
    }
  }
}

---

## FILE: backend/src/game/game.module.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { GameGateway } from './game.gateway';
import { TransactionBatchProcessor } from './transaction-batch.processor';
import { TransactionReceiptGuard } from './transaction-receipt.guard';
import { SessionModule } from '../session/session.module';
import { PaymasterModule } from '../paymaster/paymaster.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'transactions',
    }),
    SessionModule,
    PaymasterModule,
  ],
  providers: [GameGateway, TransactionBatchProcessor, TransactionReceiptGuard],
  exports: [GameGateway],
})
export class GameModule {}

---

## FILE: backend/src/game/transaction-batch.processor.ts
import { Process, Processor } from '@nestjs/bull';
import { Job } from 'bull';
import { Logger } from '@nestjs/common';
import { PaymasterService } from '../paymaster/paymaster.service';
import { TransactionReceiptGuard } from './transaction-receipt.guard';

@Processor('transactions')
export class TransactionBatchProcessor {
  private readonly logger = new Logger(TransactionBatchProcessor.name);
  private actionBatch: any[] = [];
  private readonly BATCH_SIZE = 100;

  constructor(
    private paymasterService: PaymasterService,
    private receiptGuard: TransactionReceiptGuard,
  ) {}

  @Process('batch-action')
  async handleBatchAction(job: Job) {
    this.actionBatch.push(job.data);

    if (this.actionBatch.length >= this.BATCH_SIZE) {
      await this.submitBatch();
    }
  }

  private async submitBatch() {
    if (this.actionBatch.length === 0) return;

    this.logger.log(`Submitting batch of ${this.actionBatch.length} actions`);

    try {
      // Group by user and submit
      const userActions = this.groupByUser(this.actionBatch);

      for (const [userId, actions] of Object.entries(userActions)) {
        await this.submitUserBatch(userId, actions);
      }

      this.actionBatch = [];
      this.logger.log('Batch submitted successfully');
    } catch (error) {
      this.logger.error('Batch submission failed', error);
    }
  }

  private groupByUser(actions: any[]): Record<string, any[]> {
    return actions.reduce((groups, action) => {
      const userId = action.userId;
      if (!groups[userId]) groups[userId] = [];
      groups[userId].push(action);
      return groups;
    }, {});
  }

  private async submitUserBatch(userId: string, actions: any[]) {
    // Submit with paymaster
    const sponsored = await this.paymasterService.sponsorTransaction({
      userId,
      actions,
    });

    // Track transaction for receipt monitoring
    if (sponsored.transaction_hash || sponsored.transactionHash) {
      const txHash = sponsored.transaction_hash || sponsored.transactionHash;
      await this.receiptGuard.trackTransaction(txHash, {
        userId,
        actions,
      });
    }

    this.logger.log(`Batch sponsored: ${sponsored.transaction_hash || sponsored.transactionHash}`);
    return sponsored;
  }
}

---

## FILE: backend/src/game/transaction-receipt.guard.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { RpcProvider } from 'starknet';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class TransactionReceiptGuard {
  private readonly logger = new Logger(TransactionReceiptGuard.name);
  private provider: RpcProvider | null = null;
  private pendingTransactions = new Map<string, any>();

  constructor(
    private configService: ConfigService,
    @InjectQueue('transactions') private txQueue: Queue,
  ) {
    // Check pending transactions every 10 seconds
    setInterval(() => this.checkPendingTransactions(), 10000);
  }

  private getProvider(): RpcProvider {
    if (!this.provider) {
      this.provider = new RpcProvider({
        nodeUrl: this.configService.get('STARKNET_RPC') || 'https://starknet-sepolia.public.blastapi.io',
      });
    }
    return this.provider;
  }

  async trackTransaction(txHash: string, originalData: any) {
    this.pendingTransactions.set(txHash, {
      ...originalData,
      attempts: 0,
      submittedAt: Date.now(),
    });
  }

  private async checkPendingTransactions() {
    const provider = this.getProvider();
    for (const [txHash, data] of this.pendingTransactions.entries()) {
      try {
        const receipt = await provider.getTransactionReceipt(txHash);

        if (receipt.status === 'ACCEPTED_ON_L2' || receipt.status === 'ACCEPTED_ON_L1') {
          this.logger.log(`Transaction confirmed: ${txHash}`);
          this.pendingTransactions.delete(txHash);
        } else if (receipt.status === 'REJECTED') {
          this.logger.warn(`Transaction rejected, requeuing: ${txHash}`);
          await this.requeueTransaction(data);
          this.pendingTransactions.delete(txHash);
        }
      } catch (error: any) {
        // Transaction not found yet, check timeout
        if (Date.now() - data.submittedAt > 300000) { // 5 minutes timeout
          this.logger.error(`Transaction timeout, requeuing: ${txHash}`);
          await this.requeueTransaction(data);
          this.pendingTransactions.delete(txHash);
        }
      }
    }
  }

  private async requeueTransaction(data: any) {
    if (data.attempts < 3) {
      await this.txQueue.add('batch-action', {
        ...data,
        attempts: data.attempts + 1,
        requeued: true,
      }, {
        delay: 5000 * (data.attempts + 1), // Exponential delay
      });
    } else {
      this.logger.error(`Max retries exceeded for transaction`);
      // Store in dead letter queue or alert
    }
  }
}

---

## FILE: backend/src/paymaster/paymaster.module.ts
import { Module } from '@nestjs/common';
import { PaymasterService } from './paymaster.service';

@Module({
  providers: [PaymasterService],
  exports: [PaymasterService],
})
export class PaymasterModule {}

---

## FILE: backend/src/paymaster/paymaster.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { backOff } from 'exponential-backoff';
import * as crypto from 'crypto';

interface PaymasterCache {
  headers: Record<string, string>;
  expiresAt: number;
}

@Injectable()
export class PaymasterService {
  private readonly logger = new Logger(PaymasterService.name);
  private paymasterUrl: string | null = null;
  private apiKey: string | null = null;
  private authCache: PaymasterCache | null = null;
  private requestQueue: Promise<any>[] = [];
  private readonly MAX_CONCURRENT = 10;

  constructor(private configService: ConfigService) {}

  private getPaymasterUrl(): string {
    if (!this.paymasterUrl) {
      this.paymasterUrl = this.configService.get('AVNU_PAYMASTER_URL') || 'https://sepolia.paymaster.avnu.fi';
    }
    return this.paymasterUrl;
  }

  private getApiKey(): string {
    if (!this.apiKey) {
      this.apiKey = this.configService.get('AVNU_API_KEY') || '';
    }
    return this.apiKey;
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    // Cache auth headers for 1 hour
    if (this.authCache && this.authCache.expiresAt > Date.now()) {
      return this.authCache.headers;
    }

    const headers = {
      'Content-Type': 'application/json',
      'API-Key': this.getApiKey(),
      'X-Request-ID': crypto.randomUUID(),
    };

    this.authCache = {
      headers,
      expiresAt: Date.now() + 3600000, // 1 hour
    };

    return headers;
  }

  async sponsorTransaction(transaction: any): Promise<any> {
    return await backOff(
      async () => {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.getPaymasterUrl()}/sponsor`, {
          method: 'POST',
          headers,
          body: JSON.stringify(transaction),
        });

        let responseData: any;
        try {
          responseData = await response.json();
        } catch (e) {
          // If response is not JSON, use status text
          responseData = { error: response.statusText };
        }

        // Handle specific error codes
        if (!response.ok) {
          const error = this.parsePaymasterError(response.status, responseData);

          // Determine if error is retryable
          if (error.retryable) {
            throw new Error(`Retryable error: ${error.message}`);
          } else {
            throw new Error(`Non-retryable error: ${error.message}`);
          }
        }

        return responseData;
      },
      {
        numOfAttempts: 5,
        startingDelay: 1000,
        timeMultiple: 2,
        maxDelay: 30000,
        retry: (error) => {
          return error.message.includes('Retryable');
        },
      }
    );
  }

  async sponsorAccountDeployment(deployPayload: any): Promise<any> {
    // Similar to sponsorTransaction but for account deployment
    const headers = await this.getAuthHeaders();

    return await backOff(
      async () => {
        const response = await fetch(`${this.getPaymasterUrl()}/sponsor-account-deployment`, {
          method: 'POST',
          headers,
          body: JSON.stringify(deployPayload),
        });

        if (!response.ok) {
          let errorData: any;
          try {
            errorData = await response.json();
          } catch (e) {
            errorData = { error: response.statusText };
          }
          const error = this.parsePaymasterError(response.status, errorData);

          if (error.retryable) {
            throw new Error(`Retryable: ${error.message}`);
          }
          throw new Error(`Fatal: ${error.message}`);
        }

        try {
          return await response.json();
        } catch (e) {
          return { transaction_hash: 'unknown', success: true };
        }
      },
      {
        numOfAttempts: 3,
        startingDelay: 2000,
      }
    );
  }

  private parsePaymasterError(status: number, data: any) {
    const errorMap: Record<number, { message: string; retryable: boolean }> = {
      429: { message: 'Rate limit exceeded', retryable: true },
      503: { message: 'Service temporarily unavailable', retryable: true },
      502: { message: 'Bad gateway', retryable: true },
      500: { message: 'Internal server error', retryable: true },
      401: { message: 'Invalid API key', retryable: false },
      400: { message: `Bad request: ${data.error || 'Invalid data'}`, retryable: false },
      402: { message: 'Insufficient credits', retryable: false },
    };

    return errorMap[status] || {
      message: `Unknown error: ${status}`,
      retryable: status >= 500,
    };
  }
}

---

## FILE: unity-client/Assets/Plugins/Android/AndroidKeystore.cs
using UnityEngine;
using System;

public static class AndroidKeystore
{
    private static AndroidJavaObject GetKeystore()
    {
        using (var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
        using (var activity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity"))
        using (var context = activity.Call<AndroidJavaObject>("getApplicationContext"))
        {
            return new AndroidJavaObject("android.security.KeyStore", context);
        }
    }

    public static void SaveSecureString(string key, string value)
    {
        #if UNITY_ANDROID && !UNITY_EDITOR
        try
        {
            using (var keystore = GetKeystore())
            {
                // Use Android Keystore to encrypt
                var encryptedData = EncryptWithKeystore(value);
                PlayerPrefs.SetString($"secure_{key}", encryptedData);
                PlayerPrefs.Save();
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Android Keystore error: {e.Message}");
            // Fallback to encrypted PlayerPrefs
            SecureStorage.SaveSecure(key, value);
        }
        #else
        SecureStorage.SaveSecure(key, value);
        #endif
    }

    private static string EncryptWithKeystore(string plainText)
    {
        // Implementation using Android Keystore API
        // This requires a custom Android plugin or Unity's native plugin interface
        return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(plainText));
    }
}

---

## FILE: unity-client/Assets/Plugins/iOS/iOSKeychain.cs
using System.Runtime.InteropServices;
using UnityEngine;

public static class iOSKeychain
{
    #if UNITY_IOS && !UNITY_EDITOR
    [DllImport("__Internal")]
    private static extern void _SaveToKeychain(string key, string value);

    [DllImport("__Internal")]
    private static extern string _LoadFromKeychain(string key);

    [DllImport("__Internal")]
    private static extern void _DeleteFromKeychain(string key);
    #endif

    public static void SetString(string key, string value)
    {
        #if UNITY_IOS && !UNITY_EDITOR
        _SaveToKeychain(key, value);
        #else
        SecureStorage.SaveSecure(key, value);
        #endif
    }

    public static string GetString(string key)
    {
        #if UNITY_IOS && !UNITY_EDITOR
        return _LoadFromKeychain(key);
        #else
        return SecureStorage.LoadSecure(key);
        #endif
    }
}

---

## FILE: unity-client/Assets/Scripts/SecureStorage.cs
using UnityEngine;
using System;
using System.Text;
using System.Security.Cryptography;

/// <summary>
/// Cross-platform secure storage wrapper for iOS Keychain and Android Keystore
/// Falls back to encrypted PlayerPrefs if native plugins are unavailable
/// </summary>
public static class SecureStorage
{
    private static readonly string ENCRYPTION_KEY = "YourEncryptionKey1234567890123456"; // 32 chars for AES-256

    /// <summary>
    /// Save a secure string value
    /// </summary>
    public static void SaveSecure(string key, string value)
    {
        #if UNITY_IOS && !UNITY_EDITOR
        iOSKeychain.SetString(key, value);
        #elif UNITY_ANDROID && !UNITY_EDITOR
        AndroidKeystore.SaveSecureString(key, value);
        #else
        // Fallback to encrypted PlayerPrefs for editor/testing
        string encrypted = Encrypt(value);
        PlayerPrefs.SetString($"secure_{key}", encrypted);
        PlayerPrefs.Save();
        #endif
    }

    /// <summary>
    /// Load a secure string value
    /// </summary>
    public static string LoadSecure(string key)
    {
        #if UNITY_IOS && !UNITY_EDITOR
        return iOSKeychain.GetString(key);
        #elif UNITY_ANDROID && !UNITY_EDITOR
        // Android implementation would read from keystore
        string encrypted = PlayerPrefs.GetString($"secure_{key}", "");
        return encrypted != "" ? Decrypt(encrypted) : "";
        #else
        // Fallback to encrypted PlayerPrefs for editor/testing
        string encrypted = PlayerPrefs.GetString($"secure_{key}", "");
        return encrypted != "" ? Decrypt(encrypted) : "";
        #endif
    }

    /// <summary>
    /// Delete a secure value
    /// </summary>
    public static void DeleteSecure(string key)
    {
        #if UNITY_IOS && !UNITY_EDITOR
        // iOS implementation would call delete function
        #endif
        
        PlayerPrefs.DeleteKey($"secure_{key}");
        PlayerPrefs.Save();
    }

    /// <summary>
    /// Simple AES encryption for fallback (editor/testing)
    /// </summary>
    private static string Encrypt(string plainText)
    {
        byte[] iv = new byte[16];
        using (Aes aes = Aes.Create())
        {
            aes.Key = Encoding.UTF8.GetBytes(ENCRYPTION_KEY);
            aes.IV = iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;

            ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

            using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))
                    {
                        swEncrypt.Write(plainText);
                    }
                }
                return Convert.ToBase64String(msEncrypt.ToArray());
            }
        }
    }

    /// <summary>
    /// Simple AES decryption for fallback (editor/testing)
    /// </summary>
    private static string Decrypt(string cipherText)
    {
        byte[] iv = new byte[16];
        byte[] buffer = Convert.FromBase64String(cipherText);

        using (Aes aes = Aes.Create())
        {
            aes.Key = Encoding.UTF8.GetBytes(ENCRYPTION_KEY);
            aes.IV = iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;

            ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

            using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(buffer))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                    {
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }
    }
}

---

